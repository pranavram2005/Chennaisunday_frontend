{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nvar ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');\nvar DOMNamespaces = require('./DOMNamespaces');\nvar WHITESPACE_TEST = /^[ \\r\\n\\t\\f]/;\nvar NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \\r\\n\\t\\f\\/>]/;\nvar createMicrosoftUnsafeLocalFunction = require('./createMicrosoftUnsafeLocalFunction');\n\n// SVG temp container for IE lacking innerHTML\nvar reusableSVGContainer;\n\n/**\n * Set the innerHTML property of a node, ensuring that whitespace is preserved\n * even in IE8.\n *\n * @param {DOMElement} node\n * @param {string} html\n * @internal\n */\nvar setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {\n  // IE does not have innerHTML for SVG nodes, so instead we inject the\n  // new markup in a temp node and then move the child nodes across into\n  // the target node\n  if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {\n    reusableSVGContainer = reusableSVGContainer || document.createElement('div');\n    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';\n    var svgNode = reusableSVGContainer.firstChild;\n    while (svgNode.firstChild) {\n      node.appendChild(svgNode.firstChild);\n    }\n  } else {\n    node.innerHTML = html;\n  }\n});\nif (ExecutionEnvironment.canUseDOM) {\n  // IE8: When updating a just created node with innerHTML only leading\n  // whitespace is removed. When updating an existing node with innerHTML\n  // whitespace in root TextNodes is also collapsed.\n  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html\n\n  // Feature detection; only IE8 is known to behave improperly like this.\n  var testElement = document.createElement('div');\n  testElement.innerHTML = ' ';\n  if (testElement.innerHTML === '') {\n    setInnerHTML = function (node, html) {\n      // Magic theory: IE8 supposedly differentiates between added and updated\n      // nodes when processing innerHTML, innerHTML on updated nodes suffers\n      // from worse whitespace behavior. Re-adding a node like this triggers\n      // the initial and more favorable whitespace behavior.\n      // TODO: What to do on a detached node?\n      if (node.parentNode) {\n        node.parentNode.replaceChild(node, node);\n      }\n\n      // We also implement a workaround for non-visible tags disappearing into\n      // thin air on IE8, this only happens if there is no visible text\n      // in-front of the non-visible tags. Piggyback on the whitespace fix\n      // and simply check if any non-visible tags appear in the source.\n      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {\n        // Recover leading whitespace by temporarily prepending any character.\n        // \\uFEFF has the potential advantage of being zero-width/invisible.\n        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode\n        // in hopes that this is preserved even if \"\\uFEFF\" is transformed to\n        // the actual Unicode character (by Babel, for example).\n        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216\n        node.innerHTML = String.fromCharCode(0xfeff) + html;\n\n        // deleteData leaves an empty `TextNode` which offsets the index of all\n        // children. Definitely want to avoid this.\n        var textNode = node.firstChild;\n        if (textNode.data.length === 1) {\n          node.removeChild(textNode);\n        } else {\n          textNode.deleteData(0, 1);\n        }\n      } else {\n        node.innerHTML = html;\n      }\n    };\n  }\n  testElement = null;\n}\nmodule.exports = setInnerHTML;","map":{"version":3,"names":["ExecutionEnvironment","require","DOMNamespaces","WHITESPACE_TEST","NONVISIBLE_TEST","createMicrosoftUnsafeLocalFunction","reusableSVGContainer","setInnerHTML","node","html","namespaceURI","svg","document","createElement","innerHTML","svgNode","firstChild","appendChild","canUseDOM","testElement","parentNode","replaceChild","test","String","fromCharCode","textNode","data","length","removeChild","deleteData","module","exports"],"sources":["D:/Project_CS/react_side/myapp/node_modules/react-file-viewer/node_modules/react-dom/lib/setInnerHTML.js"],"sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nvar ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');\nvar DOMNamespaces = require('./DOMNamespaces');\n\nvar WHITESPACE_TEST = /^[ \\r\\n\\t\\f]/;\nvar NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \\r\\n\\t\\f\\/>]/;\n\nvar createMicrosoftUnsafeLocalFunction = require('./createMicrosoftUnsafeLocalFunction');\n\n// SVG temp container for IE lacking innerHTML\nvar reusableSVGContainer;\n\n/**\n * Set the innerHTML property of a node, ensuring that whitespace is preserved\n * even in IE8.\n *\n * @param {DOMElement} node\n * @param {string} html\n * @internal\n */\nvar setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {\n  // IE does not have innerHTML for SVG nodes, so instead we inject the\n  // new markup in a temp node and then move the child nodes across into\n  // the target node\n  if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {\n    reusableSVGContainer = reusableSVGContainer || document.createElement('div');\n    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';\n    var svgNode = reusableSVGContainer.firstChild;\n    while (svgNode.firstChild) {\n      node.appendChild(svgNode.firstChild);\n    }\n  } else {\n    node.innerHTML = html;\n  }\n});\n\nif (ExecutionEnvironment.canUseDOM) {\n  // IE8: When updating a just created node with innerHTML only leading\n  // whitespace is removed. When updating an existing node with innerHTML\n  // whitespace in root TextNodes is also collapsed.\n  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html\n\n  // Feature detection; only IE8 is known to behave improperly like this.\n  var testElement = document.createElement('div');\n  testElement.innerHTML = ' ';\n  if (testElement.innerHTML === '') {\n    setInnerHTML = function (node, html) {\n      // Magic theory: IE8 supposedly differentiates between added and updated\n      // nodes when processing innerHTML, innerHTML on updated nodes suffers\n      // from worse whitespace behavior. Re-adding a node like this triggers\n      // the initial and more favorable whitespace behavior.\n      // TODO: What to do on a detached node?\n      if (node.parentNode) {\n        node.parentNode.replaceChild(node, node);\n      }\n\n      // We also implement a workaround for non-visible tags disappearing into\n      // thin air on IE8, this only happens if there is no visible text\n      // in-front of the non-visible tags. Piggyback on the whitespace fix\n      // and simply check if any non-visible tags appear in the source.\n      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {\n        // Recover leading whitespace by temporarily prepending any character.\n        // \\uFEFF has the potential advantage of being zero-width/invisible.\n        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode\n        // in hopes that this is preserved even if \"\\uFEFF\" is transformed to\n        // the actual Unicode character (by Babel, for example).\n        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216\n        node.innerHTML = String.fromCharCode(0xfeff) + html;\n\n        // deleteData leaves an empty `TextNode` which offsets the index of all\n        // children. Definitely want to avoid this.\n        var textNode = node.firstChild;\n        if (textNode.data.length === 1) {\n          node.removeChild(textNode);\n        } else {\n          textNode.deleteData(0, 1);\n        }\n      } else {\n        node.innerHTML = html;\n      }\n    };\n  }\n  testElement = null;\n}\n\nmodule.exports = setInnerHTML;"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,IAAIA,oBAAoB,GAAGC,OAAO,CAAC,+BAA+B,CAAC;AACnE,IAAIC,aAAa,GAAGD,OAAO,CAAC,iBAAiB,CAAC;AAE9C,IAAIE,eAAe,GAAG,cAAc;AACpC,IAAIC,eAAe,GAAG,sDAAsD;AAE5E,IAAIC,kCAAkC,GAAGJ,OAAO,CAAC,sCAAsC,CAAC;;AAExF;AACA,IAAIK,oBAAoB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,YAAY,GAAGF,kCAAkC,CAAC,UAAUG,IAAI,EAAEC,IAAI,EAAE;EAC1E;EACA;EACA;EACA,IAAID,IAAI,CAACE,YAAY,KAAKR,aAAa,CAACS,GAAG,IAAI,EAAE,WAAW,IAAIH,IAAI,CAAC,EAAE;IACrEF,oBAAoB,GAAGA,oBAAoB,IAAIM,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC;IAC5EP,oBAAoB,CAACQ,SAAS,GAAG,OAAO,GAAGL,IAAI,GAAG,QAAQ;IAC1D,IAAIM,OAAO,GAAGT,oBAAoB,CAACU,UAAU;IAC7C,OAAOD,OAAO,CAACC,UAAU,EAAE;MACzBR,IAAI,CAACS,WAAW,CAACF,OAAO,CAACC,UAAU,CAAC;IACtC;EACF,CAAC,MAAM;IACLR,IAAI,CAACM,SAAS,GAAGL,IAAI;EACvB;AACF,CAAC,CAAC;AAEF,IAAIT,oBAAoB,CAACkB,SAAS,EAAE;EAClC;EACA;EACA;EACA;;EAEA;EACA,IAAIC,WAAW,GAAGP,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC;EAC/CM,WAAW,CAACL,SAAS,GAAG,GAAG;EAC3B,IAAIK,WAAW,CAACL,SAAS,KAAK,EAAE,EAAE;IAChCP,YAAY,GAAG,SAAAA,CAAUC,IAAI,EAAEC,IAAI,EAAE;MACnC;MACA;MACA;MACA;MACA;MACA,IAAID,IAAI,CAACY,UAAU,EAAE;QACnBZ,IAAI,CAACY,UAAU,CAACC,YAAY,CAACb,IAAI,EAAEA,IAAI,CAAC;MAC1C;;MAEA;MACA;MACA;MACA;MACA,IAAIL,eAAe,CAACmB,IAAI,CAACb,IAAI,CAAC,IAAIA,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,IAAIL,eAAe,CAACkB,IAAI,CAACb,IAAI,CAAC,EAAE;QAC/E;QACA;QACA;QACA;QACA;QACA;QACAD,IAAI,CAACM,SAAS,GAAGS,MAAM,CAACC,YAAY,CAAC,MAAM,CAAC,GAAGf,IAAI;;QAEnD;QACA;QACA,IAAIgB,QAAQ,GAAGjB,IAAI,CAACQ,UAAU;QAC9B,IAAIS,QAAQ,CAACC,IAAI,CAACC,MAAM,KAAK,CAAC,EAAE;UAC9BnB,IAAI,CAACoB,WAAW,CAACH,QAAQ,CAAC;QAC5B,CAAC,MAAM;UACLA,QAAQ,CAACI,UAAU,CAAC,CAAC,EAAE,CAAC,CAAC;QAC3B;MACF,CAAC,MAAM;QACLrB,IAAI,CAACM,SAAS,GAAGL,IAAI;MACvB;IACF,CAAC;EACH;EACAU,WAAW,GAAG,IAAI;AACpB;AAEAW,MAAM,CAACC,OAAO,GAAGxB,YAAY","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}