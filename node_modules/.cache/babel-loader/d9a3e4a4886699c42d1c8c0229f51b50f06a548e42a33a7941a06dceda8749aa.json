{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nvar EventPluginHub = require('./EventPluginHub');\nvar EventPropagators = require('./EventPropagators');\nvar ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');\nvar ReactDOMComponentTree = require('./ReactDOMComponentTree');\nvar ReactUpdates = require('./ReactUpdates');\nvar SyntheticEvent = require('./SyntheticEvent');\nvar inputValueTracking = require('./inputValueTracking');\nvar getEventTarget = require('./getEventTarget');\nvar isEventSupported = require('./isEventSupported');\nvar isTextInputElement = require('./isTextInputElement');\nvar eventTypes = {\n  change: {\n    phasedRegistrationNames: {\n      bubbled: 'onChange',\n      captured: 'onChangeCapture'\n    },\n    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']\n  }\n};\nfunction createAndAccumulateChangeEvent(inst, nativeEvent, target) {\n  var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, target);\n  event.type = 'change';\n  EventPropagators.accumulateTwoPhaseDispatches(event);\n  return event;\n}\n/**\n * For IE shims\n */\nvar activeElement = null;\nvar activeElementInst = null;\n\n/**\n * SECTION: handle `change` event\n */\nfunction shouldUseChangeEvent(elem) {\n  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';\n}\nvar doesChangeEventBubble = false;\nif (ExecutionEnvironment.canUseDOM) {\n  // See `handleChange` comment below\n  doesChangeEventBubble = isEventSupported('change') && (!document.documentMode || document.documentMode > 8);\n}\nfunction manualDispatchChangeEvent(nativeEvent) {\n  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));\n\n  // If change and propertychange bubbled, we'd just bind to it like all the\n  // other events and have it go through ReactBrowserEventEmitter. Since it\n  // doesn't, we manually listen for the events and so we have to enqueue and\n  // process the abstract event manually.\n  //\n  // Batching is necessary here in order to ensure that all event handlers run\n  // before the next rerender (including event handlers attached to ancestor\n  // elements instead of directly on the input). Without this, controlled\n  // components don't work properly in conjunction with event bubbling because\n  // the component is rerendered and the value reverted before all the event\n  // handlers can run. See https://github.com/facebook/react/issues/708.\n  ReactUpdates.batchedUpdates(runEventInBatch, event);\n}\nfunction runEventInBatch(event) {\n  EventPluginHub.enqueueEvents(event);\n  EventPluginHub.processEventQueue(false);\n}\nfunction startWatchingForChangeEventIE8(target, targetInst) {\n  activeElement = target;\n  activeElementInst = targetInst;\n  activeElement.attachEvent('onchange', manualDispatchChangeEvent);\n}\nfunction stopWatchingForChangeEventIE8() {\n  if (!activeElement) {\n    return;\n  }\n  activeElement.detachEvent('onchange', manualDispatchChangeEvent);\n  activeElement = null;\n  activeElementInst = null;\n}\nfunction getInstIfValueChanged(targetInst, nativeEvent) {\n  var updated = inputValueTracking.updateValueIfChanged(targetInst);\n  var simulated = nativeEvent.simulated === true && ChangeEventPlugin._allowSimulatedPassThrough;\n  if (updated || simulated) {\n    return targetInst;\n  }\n}\nfunction getTargetInstForChangeEvent(topLevelType, targetInst) {\n  if (topLevelType === 'topChange') {\n    return targetInst;\n  }\n}\nfunction handleEventsForChangeEventIE8(topLevelType, target, targetInst) {\n  if (topLevelType === 'topFocus') {\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForChangeEventIE8();\n    startWatchingForChangeEventIE8(target, targetInst);\n  } else if (topLevelType === 'topBlur') {\n    stopWatchingForChangeEventIE8();\n  }\n}\n\n/**\n * SECTION: handle `input` event\n */\nvar isInputEventSupported = false;\nif (ExecutionEnvironment.canUseDOM) {\n  // IE9 claims to support the input event but fails to trigger it when\n  // deleting text, so we ignore its input events.\n\n  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);\n}\n\n/**\n * (For IE <=9) Starts tracking propertychange events on the passed-in element\n * and override the value property so that we can distinguish user events from\n * value changes in JS.\n */\nfunction startWatchingForValueChange(target, targetInst) {\n  activeElement = target;\n  activeElementInst = targetInst;\n  activeElement.attachEvent('onpropertychange', handlePropertyChange);\n}\n\n/**\n * (For IE <=9) Removes the event listeners from the currently-tracked element,\n * if any exists.\n */\nfunction stopWatchingForValueChange() {\n  if (!activeElement) {\n    return;\n  }\n  activeElement.detachEvent('onpropertychange', handlePropertyChange);\n  activeElement = null;\n  activeElementInst = null;\n}\n\n/**\n * (For IE <=9) Handles a propertychange event, sending a `change` event if\n * the value of the active element has changed.\n */\nfunction handlePropertyChange(nativeEvent) {\n  if (nativeEvent.propertyName !== 'value') {\n    return;\n  }\n  if (getInstIfValueChanged(activeElementInst, nativeEvent)) {\n    manualDispatchChangeEvent(nativeEvent);\n  }\n}\nfunction handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {\n  if (topLevelType === 'topFocus') {\n    // In IE8, we can capture almost all .value changes by adding a\n    // propertychange handler and looking for events with propertyName\n    // equal to 'value'\n    // In IE9, propertychange fires for most input events but is buggy and\n    // doesn't fire when text is deleted, but conveniently, selectionchange\n    // appears to fire in all of the remaining cases so we catch those and\n    // forward the event if the value has changed\n    // In either case, we don't want to call the event handler if the value\n    // is changed from JS so we redefine a setter for `.value` that updates\n    // our activeElementValue variable, allowing us to ignore those changes\n    //\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForValueChange();\n    startWatchingForValueChange(target, targetInst);\n  } else if (topLevelType === 'topBlur') {\n    stopWatchingForValueChange();\n  }\n}\n\n// For IE8 and IE9.\nfunction getTargetInstForInputEventPolyfill(topLevelType, targetInst, nativeEvent) {\n  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {\n    // On the selectionchange event, the target is just document which isn't\n    // helpful for us so just check activeElement instead.\n    //\n    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n    // propertychange on the first input event after setting `value` from a\n    // script and fires only keydown, keypress, keyup. Catching keyup usually\n    // gets it and catching keydown lets us fire an event for the first\n    // keystroke if user does a key repeat (it'll be a little delayed: right\n    // before the second keystroke). Other input methods (e.g., paste) seem to\n    // fire selectionchange normally.\n    return getInstIfValueChanged(activeElementInst, nativeEvent);\n  }\n}\n\n/**\n * SECTION: handle `click` event\n */\nfunction shouldUseClickEvent(elem) {\n  // Use the `click` event to detect changes to checkbox and radio inputs.\n  // This approach works across all browsers, whereas `change` does not fire\n  // until `blur` in IE8.\n  var nodeName = elem.nodeName;\n  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');\n}\nfunction getTargetInstForClickEvent(topLevelType, targetInst, nativeEvent) {\n  if (topLevelType === 'topClick') {\n    return getInstIfValueChanged(targetInst, nativeEvent);\n  }\n}\nfunction getTargetInstForInputOrChangeEvent(topLevelType, targetInst, nativeEvent) {\n  if (topLevelType === 'topInput' || topLevelType === 'topChange') {\n    return getInstIfValueChanged(targetInst, nativeEvent);\n  }\n}\nfunction handleControlledInputBlur(inst, node) {\n  // TODO: In IE, inst is occasionally null. Why?\n  if (inst == null) {\n    return;\n  }\n\n  // Fiber and ReactDOM keep wrapper state in separate places\n  var state = inst._wrapperState || node._wrapperState;\n  if (!state || !state.controlled || node.type !== 'number') {\n    return;\n  }\n\n  // If controlled, assign the value attribute to the current value on blur\n  var value = '' + node.value;\n  if (node.getAttribute('value') !== value) {\n    node.setAttribute('value', value);\n  }\n}\n\n/**\n * This plugin creates an `onChange` event that normalizes change events\n * across form elements. This event fires at a time when it's possible to\n * change the element's value without seeing a flicker.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - select\n */\nvar ChangeEventPlugin = {\n  eventTypes: eventTypes,\n  _allowSimulatedPassThrough: true,\n  _isInputEventSupported: isInputEventSupported,\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;\n    var getTargetInstFunc, handleEventFunc;\n    if (shouldUseChangeEvent(targetNode)) {\n      if (doesChangeEventBubble) {\n        getTargetInstFunc = getTargetInstForChangeEvent;\n      } else {\n        handleEventFunc = handleEventsForChangeEventIE8;\n      }\n    } else if (isTextInputElement(targetNode)) {\n      if (isInputEventSupported) {\n        getTargetInstFunc = getTargetInstForInputOrChangeEvent;\n      } else {\n        getTargetInstFunc = getTargetInstForInputEventPolyfill;\n        handleEventFunc = handleEventsForInputEventPolyfill;\n      }\n    } else if (shouldUseClickEvent(targetNode)) {\n      getTargetInstFunc = getTargetInstForClickEvent;\n    }\n    if (getTargetInstFunc) {\n      var inst = getTargetInstFunc(topLevelType, targetInst, nativeEvent);\n      if (inst) {\n        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);\n        return event;\n      }\n    }\n    if (handleEventFunc) {\n      handleEventFunc(topLevelType, targetNode, targetInst);\n    }\n\n    // When blurring, set the value attribute for number inputs\n    if (topLevelType === 'topBlur') {\n      handleControlledInputBlur(targetInst, targetNode);\n    }\n  }\n};\nmodule.exports = ChangeEventPlugin;","map":{"version":3,"names":["EventPluginHub","require","EventPropagators","ExecutionEnvironment","ReactDOMComponentTree","ReactUpdates","SyntheticEvent","inputValueTracking","getEventTarget","isEventSupported","isTextInputElement","eventTypes","change","phasedRegistrationNames","bubbled","captured","dependencies","createAndAccumulateChangeEvent","inst","nativeEvent","target","event","getPooled","type","accumulateTwoPhaseDispatches","activeElement","activeElementInst","shouldUseChangeEvent","elem","nodeName","toLowerCase","doesChangeEventBubble","canUseDOM","document","documentMode","manualDispatchChangeEvent","batchedUpdates","runEventInBatch","enqueueEvents","processEventQueue","startWatchingForChangeEventIE8","targetInst","attachEvent","stopWatchingForChangeEventIE8","detachEvent","getInstIfValueChanged","updated","updateValueIfChanged","simulated","ChangeEventPlugin","_allowSimulatedPassThrough","getTargetInstForChangeEvent","topLevelType","handleEventsForChangeEventIE8","isInputEventSupported","startWatchingForValueChange","handlePropertyChange","stopWatchingForValueChange","propertyName","handleEventsForInputEventPolyfill","getTargetInstForInputEventPolyfill","shouldUseClickEvent","getTargetInstForClickEvent","getTargetInstForInputOrChangeEvent","handleControlledInputBlur","node","state","_wrapperState","controlled","value","getAttribute","setAttribute","_isInputEventSupported","extractEvents","nativeEventTarget","targetNode","getNodeFromInstance","window","getTargetInstFunc","handleEventFunc","module","exports"],"sources":["D:/Project_CS/react_side/myapp/node_modules/react-file-viewer/node_modules/react-dom/lib/ChangeEventPlugin.js"],"sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nvar EventPluginHub = require('./EventPluginHub');\nvar EventPropagators = require('./EventPropagators');\nvar ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');\nvar ReactDOMComponentTree = require('./ReactDOMComponentTree');\nvar ReactUpdates = require('./ReactUpdates');\nvar SyntheticEvent = require('./SyntheticEvent');\n\nvar inputValueTracking = require('./inputValueTracking');\nvar getEventTarget = require('./getEventTarget');\nvar isEventSupported = require('./isEventSupported');\nvar isTextInputElement = require('./isTextInputElement');\n\nvar eventTypes = {\n  change: {\n    phasedRegistrationNames: {\n      bubbled: 'onChange',\n      captured: 'onChangeCapture'\n    },\n    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']\n  }\n};\n\nfunction createAndAccumulateChangeEvent(inst, nativeEvent, target) {\n  var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, target);\n  event.type = 'change';\n  EventPropagators.accumulateTwoPhaseDispatches(event);\n  return event;\n}\n/**\n * For IE shims\n */\nvar activeElement = null;\nvar activeElementInst = null;\n\n/**\n * SECTION: handle `change` event\n */\nfunction shouldUseChangeEvent(elem) {\n  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';\n}\n\nvar doesChangeEventBubble = false;\nif (ExecutionEnvironment.canUseDOM) {\n  // See `handleChange` comment below\n  doesChangeEventBubble = isEventSupported('change') && (!document.documentMode || document.documentMode > 8);\n}\n\nfunction manualDispatchChangeEvent(nativeEvent) {\n  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));\n\n  // If change and propertychange bubbled, we'd just bind to it like all the\n  // other events and have it go through ReactBrowserEventEmitter. Since it\n  // doesn't, we manually listen for the events and so we have to enqueue and\n  // process the abstract event manually.\n  //\n  // Batching is necessary here in order to ensure that all event handlers run\n  // before the next rerender (including event handlers attached to ancestor\n  // elements instead of directly on the input). Without this, controlled\n  // components don't work properly in conjunction with event bubbling because\n  // the component is rerendered and the value reverted before all the event\n  // handlers can run. See https://github.com/facebook/react/issues/708.\n  ReactUpdates.batchedUpdates(runEventInBatch, event);\n}\n\nfunction runEventInBatch(event) {\n  EventPluginHub.enqueueEvents(event);\n  EventPluginHub.processEventQueue(false);\n}\n\nfunction startWatchingForChangeEventIE8(target, targetInst) {\n  activeElement = target;\n  activeElementInst = targetInst;\n  activeElement.attachEvent('onchange', manualDispatchChangeEvent);\n}\n\nfunction stopWatchingForChangeEventIE8() {\n  if (!activeElement) {\n    return;\n  }\n  activeElement.detachEvent('onchange', manualDispatchChangeEvent);\n  activeElement = null;\n  activeElementInst = null;\n}\n\nfunction getInstIfValueChanged(targetInst, nativeEvent) {\n  var updated = inputValueTracking.updateValueIfChanged(targetInst);\n  var simulated = nativeEvent.simulated === true && ChangeEventPlugin._allowSimulatedPassThrough;\n\n  if (updated || simulated) {\n    return targetInst;\n  }\n}\n\nfunction getTargetInstForChangeEvent(topLevelType, targetInst) {\n  if (topLevelType === 'topChange') {\n    return targetInst;\n  }\n}\n\nfunction handleEventsForChangeEventIE8(topLevelType, target, targetInst) {\n  if (topLevelType === 'topFocus') {\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForChangeEventIE8();\n    startWatchingForChangeEventIE8(target, targetInst);\n  } else if (topLevelType === 'topBlur') {\n    stopWatchingForChangeEventIE8();\n  }\n}\n\n/**\n * SECTION: handle `input` event\n */\nvar isInputEventSupported = false;\nif (ExecutionEnvironment.canUseDOM) {\n  // IE9 claims to support the input event but fails to trigger it when\n  // deleting text, so we ignore its input events.\n\n  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);\n}\n\n/**\n * (For IE <=9) Starts tracking propertychange events on the passed-in element\n * and override the value property so that we can distinguish user events from\n * value changes in JS.\n */\nfunction startWatchingForValueChange(target, targetInst) {\n  activeElement = target;\n  activeElementInst = targetInst;\n  activeElement.attachEvent('onpropertychange', handlePropertyChange);\n}\n\n/**\n * (For IE <=9) Removes the event listeners from the currently-tracked element,\n * if any exists.\n */\nfunction stopWatchingForValueChange() {\n  if (!activeElement) {\n    return;\n  }\n  activeElement.detachEvent('onpropertychange', handlePropertyChange);\n\n  activeElement = null;\n  activeElementInst = null;\n}\n\n/**\n * (For IE <=9) Handles a propertychange event, sending a `change` event if\n * the value of the active element has changed.\n */\nfunction handlePropertyChange(nativeEvent) {\n  if (nativeEvent.propertyName !== 'value') {\n    return;\n  }\n  if (getInstIfValueChanged(activeElementInst, nativeEvent)) {\n    manualDispatchChangeEvent(nativeEvent);\n  }\n}\n\nfunction handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {\n  if (topLevelType === 'topFocus') {\n    // In IE8, we can capture almost all .value changes by adding a\n    // propertychange handler and looking for events with propertyName\n    // equal to 'value'\n    // In IE9, propertychange fires for most input events but is buggy and\n    // doesn't fire when text is deleted, but conveniently, selectionchange\n    // appears to fire in all of the remaining cases so we catch those and\n    // forward the event if the value has changed\n    // In either case, we don't want to call the event handler if the value\n    // is changed from JS so we redefine a setter for `.value` that updates\n    // our activeElementValue variable, allowing us to ignore those changes\n    //\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForValueChange();\n    startWatchingForValueChange(target, targetInst);\n  } else if (topLevelType === 'topBlur') {\n    stopWatchingForValueChange();\n  }\n}\n\n// For IE8 and IE9.\nfunction getTargetInstForInputEventPolyfill(topLevelType, targetInst, nativeEvent) {\n  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {\n    // On the selectionchange event, the target is just document which isn't\n    // helpful for us so just check activeElement instead.\n    //\n    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n    // propertychange on the first input event after setting `value` from a\n    // script and fires only keydown, keypress, keyup. Catching keyup usually\n    // gets it and catching keydown lets us fire an event for the first\n    // keystroke if user does a key repeat (it'll be a little delayed: right\n    // before the second keystroke). Other input methods (e.g., paste) seem to\n    // fire selectionchange normally.\n    return getInstIfValueChanged(activeElementInst, nativeEvent);\n  }\n}\n\n/**\n * SECTION: handle `click` event\n */\nfunction shouldUseClickEvent(elem) {\n  // Use the `click` event to detect changes to checkbox and radio inputs.\n  // This approach works across all browsers, whereas `change` does not fire\n  // until `blur` in IE8.\n  var nodeName = elem.nodeName;\n  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');\n}\n\nfunction getTargetInstForClickEvent(topLevelType, targetInst, nativeEvent) {\n  if (topLevelType === 'topClick') {\n    return getInstIfValueChanged(targetInst, nativeEvent);\n  }\n}\n\nfunction getTargetInstForInputOrChangeEvent(topLevelType, targetInst, nativeEvent) {\n  if (topLevelType === 'topInput' || topLevelType === 'topChange') {\n    return getInstIfValueChanged(targetInst, nativeEvent);\n  }\n}\n\nfunction handleControlledInputBlur(inst, node) {\n  // TODO: In IE, inst is occasionally null. Why?\n  if (inst == null) {\n    return;\n  }\n\n  // Fiber and ReactDOM keep wrapper state in separate places\n  var state = inst._wrapperState || node._wrapperState;\n\n  if (!state || !state.controlled || node.type !== 'number') {\n    return;\n  }\n\n  // If controlled, assign the value attribute to the current value on blur\n  var value = '' + node.value;\n  if (node.getAttribute('value') !== value) {\n    node.setAttribute('value', value);\n  }\n}\n\n/**\n * This plugin creates an `onChange` event that normalizes change events\n * across form elements. This event fires at a time when it's possible to\n * change the element's value without seeing a flicker.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - select\n */\nvar ChangeEventPlugin = {\n  eventTypes: eventTypes,\n\n  _allowSimulatedPassThrough: true,\n  _isInputEventSupported: isInputEventSupported,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;\n\n    var getTargetInstFunc, handleEventFunc;\n    if (shouldUseChangeEvent(targetNode)) {\n      if (doesChangeEventBubble) {\n        getTargetInstFunc = getTargetInstForChangeEvent;\n      } else {\n        handleEventFunc = handleEventsForChangeEventIE8;\n      }\n    } else if (isTextInputElement(targetNode)) {\n      if (isInputEventSupported) {\n        getTargetInstFunc = getTargetInstForInputOrChangeEvent;\n      } else {\n        getTargetInstFunc = getTargetInstForInputEventPolyfill;\n        handleEventFunc = handleEventsForInputEventPolyfill;\n      }\n    } else if (shouldUseClickEvent(targetNode)) {\n      getTargetInstFunc = getTargetInstForClickEvent;\n    }\n\n    if (getTargetInstFunc) {\n      var inst = getTargetInstFunc(topLevelType, targetInst, nativeEvent);\n      if (inst) {\n        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);\n        return event;\n      }\n    }\n\n    if (handleEventFunc) {\n      handleEventFunc(topLevelType, targetNode, targetInst);\n    }\n\n    // When blurring, set the value attribute for number inputs\n    if (topLevelType === 'topBlur') {\n      handleControlledInputBlur(targetInst, targetNode);\n    }\n  }\n};\n\nmodule.exports = ChangeEventPlugin;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}