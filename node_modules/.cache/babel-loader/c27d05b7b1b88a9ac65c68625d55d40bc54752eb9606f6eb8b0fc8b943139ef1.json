{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nvar _prodInvariant = require('./reactProdInvariant'),\n  _assign = require('object-assign');\nvar CallbackQueue = require('./CallbackQueue');\nvar PooledClass = require('./PooledClass');\nvar ReactFeatureFlags = require('./ReactFeatureFlags');\nvar ReactReconciler = require('./ReactReconciler');\nvar Transaction = require('./Transaction');\nvar invariant = require('fbjs/lib/invariant');\nvar dirtyComponents = [];\nvar updateBatchNumber = 0;\nvar asapCallbackQueue = CallbackQueue.getPooled();\nvar asapEnqueued = false;\nvar batchingStrategy = null;\nfunction ensureInjected() {\n  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;\n}\nvar NESTED_UPDATES = {\n  initialize: function () {\n    this.dirtyComponentsLength = dirtyComponents.length;\n  },\n  close: function () {\n    if (this.dirtyComponentsLength !== dirtyComponents.length) {\n      // Additional updates were enqueued by componentDidUpdate handlers or\n      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run\n      // these new updates so that if A's componentDidUpdate calls setState on\n      // B, B will update before the callback A's updater provided when calling\n      // setState.\n      dirtyComponents.splice(0, this.dirtyComponentsLength);\n      flushBatchedUpdates();\n    } else {\n      dirtyComponents.length = 0;\n    }\n  }\n};\nvar UPDATE_QUEUEING = {\n  initialize: function () {\n    this.callbackQueue.reset();\n  },\n  close: function () {\n    this.callbackQueue.notifyAll();\n  }\n};\nvar TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];\nfunction ReactUpdatesFlushTransaction() {\n  this.reinitializeTransaction();\n  this.dirtyComponentsLength = null;\n  this.callbackQueue = CallbackQueue.getPooled();\n  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled( /* useCreateElement */true);\n}\n_assign(ReactUpdatesFlushTransaction.prototype, Transaction, {\n  getTransactionWrappers: function () {\n    return TRANSACTION_WRAPPERS;\n  },\n  destructor: function () {\n    this.dirtyComponentsLength = null;\n    CallbackQueue.release(this.callbackQueue);\n    this.callbackQueue = null;\n    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);\n    this.reconcileTransaction = null;\n  },\n  perform: function (method, scope, a) {\n    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`\n    // with this transaction's wrappers around it.\n    return Transaction.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);\n  }\n});\nPooledClass.addPoolingTo(ReactUpdatesFlushTransaction);\nfunction batchedUpdates(callback, a, b, c, d, e) {\n  ensureInjected();\n  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);\n}\n\n/**\n * Array comparator for ReactComponents by mount ordering.\n *\n * @param {ReactComponent} c1 first component you're comparing\n * @param {ReactComponent} c2 second component you're comparing\n * @return {number} Return value usable by Array.prototype.sort().\n */\nfunction mountOrderComparator(c1, c2) {\n  return c1._mountOrder - c2._mountOrder;\n}\nfunction runBatchedUpdates(transaction) {\n  var len = transaction.dirtyComponentsLength;\n  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;\n\n  // Since reconciling a component higher in the owner hierarchy usually (not\n  // always -- see shouldComponentUpdate()) will reconcile children, reconcile\n  // them before their children by sorting the array.\n  dirtyComponents.sort(mountOrderComparator);\n\n  // Any updates enqueued while reconciling must be performed after this entire\n  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and\n  // C, B could update twice in a single batch if C's render enqueues an update\n  // to B (since B would have already updated, we should skip it, and the only\n  // way we can know to do so is by checking the batch counter).\n  updateBatchNumber++;\n  for (var i = 0; i < len; i++) {\n    // If a component is unmounted before pending changes apply, it will still\n    // be here, but we assume that it has cleared its _pendingCallbacks and\n    // that performUpdateIfNecessary is a noop.\n    var component = dirtyComponents[i];\n\n    // If performUpdateIfNecessary happens to enqueue any new updates, we\n    // shouldn't execute the callbacks until the next render happens, so\n    // stash the callbacks first\n    var callbacks = component._pendingCallbacks;\n    component._pendingCallbacks = null;\n    var markerName;\n    if (ReactFeatureFlags.logTopLevelRenders) {\n      var namedComponent = component;\n      // Duck type TopLevelWrapper. This is probably always true.\n      if (component._currentElement.type.isReactTopLevelWrapper) {\n        namedComponent = component._renderedComponent;\n      }\n      markerName = 'React update: ' + namedComponent.getName();\n      console.time(markerName);\n    }\n    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);\n    if (markerName) {\n      console.timeEnd(markerName);\n    }\n    if (callbacks) {\n      for (var j = 0; j < callbacks.length; j++) {\n        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());\n      }\n    }\n  }\n}\nvar flushBatchedUpdates = function () {\n  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents\n  // array and perform any updates enqueued by mount-ready handlers (i.e.,\n  // componentDidUpdate) but we need to check here too in order to catch\n  // updates enqueued by setState callbacks and asap calls.\n  while (dirtyComponents.length || asapEnqueued) {\n    if (dirtyComponents.length) {\n      var transaction = ReactUpdatesFlushTransaction.getPooled();\n      transaction.perform(runBatchedUpdates, null, transaction);\n      ReactUpdatesFlushTransaction.release(transaction);\n    }\n    if (asapEnqueued) {\n      asapEnqueued = false;\n      var queue = asapCallbackQueue;\n      asapCallbackQueue = CallbackQueue.getPooled();\n      queue.notifyAll();\n      CallbackQueue.release(queue);\n    }\n  }\n};\n\n/**\n * Mark a component as needing a rerender, adding an optional callback to a\n * list of functions which will be executed once the rerender occurs.\n */\nfunction enqueueUpdate(component) {\n  ensureInjected();\n\n  // Various parts of our code (such as ReactCompositeComponent's\n  // _renderValidatedComponent) assume that calls to render aren't nested;\n  // verify that that's the case. (This is called by each top-level update\n  // function, like setState, forceUpdate, etc.; creation and\n  // destruction of top-level components is guarded in ReactMount.)\n\n  if (!batchingStrategy.isBatchingUpdates) {\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\n    return;\n  }\n  dirtyComponents.push(component);\n  if (component._updateBatchNumber == null) {\n    component._updateBatchNumber = updateBatchNumber + 1;\n  }\n}\n\n/**\n * Enqueue a callback to be run at the end of the current batching cycle. Throws\n * if no updates are currently being performed.\n */\nfunction asap(callback, context) {\n  invariant(batchingStrategy.isBatchingUpdates, \"ReactUpdates.asap: Can't enqueue an asap callback in a context where\" + 'updates are not being batched.');\n  asapCallbackQueue.enqueue(callback, context);\n  asapEnqueued = true;\n}\nvar ReactUpdatesInjection = {\n  injectReconcileTransaction: function (ReconcileTransaction) {\n    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;\n    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;\n  },\n  injectBatchingStrategy: function (_batchingStrategy) {\n    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;\n    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;\n    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;\n    batchingStrategy = _batchingStrategy;\n  }\n};\nvar ReactUpdates = {\n  /**\n   * React references `ReactReconcileTransaction` using this property in order\n   * to allow dependency injection.\n   *\n   * @internal\n   */\n  ReactReconcileTransaction: null,\n  batchedUpdates: batchedUpdates,\n  enqueueUpdate: enqueueUpdate,\n  flushBatchedUpdates: flushBatchedUpdates,\n  injection: ReactUpdatesInjection,\n  asap: asap\n};\nmodule.exports = ReactUpdates;","map":{"version":3,"names":["_prodInvariant","require","_assign","CallbackQueue","PooledClass","ReactFeatureFlags","ReactReconciler","Transaction","invariant","dirtyComponents","updateBatchNumber","asapCallbackQueue","getPooled","asapEnqueued","batchingStrategy","ensureInjected","ReactUpdates","ReactReconcileTransaction","process","env","NODE_ENV","NESTED_UPDATES","initialize","dirtyComponentsLength","length","close","splice","flushBatchedUpdates","UPDATE_QUEUEING","callbackQueue","reset","notifyAll","TRANSACTION_WRAPPERS","ReactUpdatesFlushTransaction","reinitializeTransaction","reconcileTransaction","prototype","getTransactionWrappers","destructor","release","perform","method","scope","a","call","addPoolingTo","batchedUpdates","callback","b","c","d","e","mountOrderComparator","c1","c2","_mountOrder","runBatchedUpdates","transaction","len","sort","i","component","callbacks","_pendingCallbacks","markerName","logTopLevelRenders","namedComponent","_currentElement","type","isReactTopLevelWrapper","_renderedComponent","getName","console","time","performUpdateIfNecessary","timeEnd","j","enqueue","getPublicInstance","queue","enqueueUpdate","isBatchingUpdates","push","_updateBatchNumber","asap","context","ReactUpdatesInjection","injectReconcileTransaction","ReconcileTransaction","injectBatchingStrategy","_batchingStrategy","injection","module","exports"],"sources":["D:/Project_CS/react_side/myapp/node_modules/react-file-viewer/node_modules/react-dom/lib/ReactUpdates.js"],"sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nvar _prodInvariant = require('./reactProdInvariant'),\n    _assign = require('object-assign');\n\nvar CallbackQueue = require('./CallbackQueue');\nvar PooledClass = require('./PooledClass');\nvar ReactFeatureFlags = require('./ReactFeatureFlags');\nvar ReactReconciler = require('./ReactReconciler');\nvar Transaction = require('./Transaction');\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar dirtyComponents = [];\nvar updateBatchNumber = 0;\nvar asapCallbackQueue = CallbackQueue.getPooled();\nvar asapEnqueued = false;\n\nvar batchingStrategy = null;\n\nfunction ensureInjected() {\n  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;\n}\n\nvar NESTED_UPDATES = {\n  initialize: function () {\n    this.dirtyComponentsLength = dirtyComponents.length;\n  },\n  close: function () {\n    if (this.dirtyComponentsLength !== dirtyComponents.length) {\n      // Additional updates were enqueued by componentDidUpdate handlers or\n      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run\n      // these new updates so that if A's componentDidUpdate calls setState on\n      // B, B will update before the callback A's updater provided when calling\n      // setState.\n      dirtyComponents.splice(0, this.dirtyComponentsLength);\n      flushBatchedUpdates();\n    } else {\n      dirtyComponents.length = 0;\n    }\n  }\n};\n\nvar UPDATE_QUEUEING = {\n  initialize: function () {\n    this.callbackQueue.reset();\n  },\n  close: function () {\n    this.callbackQueue.notifyAll();\n  }\n};\n\nvar TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];\n\nfunction ReactUpdatesFlushTransaction() {\n  this.reinitializeTransaction();\n  this.dirtyComponentsLength = null;\n  this.callbackQueue = CallbackQueue.getPooled();\n  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(\n  /* useCreateElement */true);\n}\n\n_assign(ReactUpdatesFlushTransaction.prototype, Transaction, {\n  getTransactionWrappers: function () {\n    return TRANSACTION_WRAPPERS;\n  },\n\n  destructor: function () {\n    this.dirtyComponentsLength = null;\n    CallbackQueue.release(this.callbackQueue);\n    this.callbackQueue = null;\n    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);\n    this.reconcileTransaction = null;\n  },\n\n  perform: function (method, scope, a) {\n    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`\n    // with this transaction's wrappers around it.\n    return Transaction.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);\n  }\n});\n\nPooledClass.addPoolingTo(ReactUpdatesFlushTransaction);\n\nfunction batchedUpdates(callback, a, b, c, d, e) {\n  ensureInjected();\n  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);\n}\n\n/**\n * Array comparator for ReactComponents by mount ordering.\n *\n * @param {ReactComponent} c1 first component you're comparing\n * @param {ReactComponent} c2 second component you're comparing\n * @return {number} Return value usable by Array.prototype.sort().\n */\nfunction mountOrderComparator(c1, c2) {\n  return c1._mountOrder - c2._mountOrder;\n}\n\nfunction runBatchedUpdates(transaction) {\n  var len = transaction.dirtyComponentsLength;\n  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;\n\n  // Since reconciling a component higher in the owner hierarchy usually (not\n  // always -- see shouldComponentUpdate()) will reconcile children, reconcile\n  // them before their children by sorting the array.\n  dirtyComponents.sort(mountOrderComparator);\n\n  // Any updates enqueued while reconciling must be performed after this entire\n  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and\n  // C, B could update twice in a single batch if C's render enqueues an update\n  // to B (since B would have already updated, we should skip it, and the only\n  // way we can know to do so is by checking the batch counter).\n  updateBatchNumber++;\n\n  for (var i = 0; i < len; i++) {\n    // If a component is unmounted before pending changes apply, it will still\n    // be here, but we assume that it has cleared its _pendingCallbacks and\n    // that performUpdateIfNecessary is a noop.\n    var component = dirtyComponents[i];\n\n    // If performUpdateIfNecessary happens to enqueue any new updates, we\n    // shouldn't execute the callbacks until the next render happens, so\n    // stash the callbacks first\n    var callbacks = component._pendingCallbacks;\n    component._pendingCallbacks = null;\n\n    var markerName;\n    if (ReactFeatureFlags.logTopLevelRenders) {\n      var namedComponent = component;\n      // Duck type TopLevelWrapper. This is probably always true.\n      if (component._currentElement.type.isReactTopLevelWrapper) {\n        namedComponent = component._renderedComponent;\n      }\n      markerName = 'React update: ' + namedComponent.getName();\n      console.time(markerName);\n    }\n\n    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);\n\n    if (markerName) {\n      console.timeEnd(markerName);\n    }\n\n    if (callbacks) {\n      for (var j = 0; j < callbacks.length; j++) {\n        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());\n      }\n    }\n  }\n}\n\nvar flushBatchedUpdates = function () {\n  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents\n  // array and perform any updates enqueued by mount-ready handlers (i.e.,\n  // componentDidUpdate) but we need to check here too in order to catch\n  // updates enqueued by setState callbacks and asap calls.\n  while (dirtyComponents.length || asapEnqueued) {\n    if (dirtyComponents.length) {\n      var transaction = ReactUpdatesFlushTransaction.getPooled();\n      transaction.perform(runBatchedUpdates, null, transaction);\n      ReactUpdatesFlushTransaction.release(transaction);\n    }\n\n    if (asapEnqueued) {\n      asapEnqueued = false;\n      var queue = asapCallbackQueue;\n      asapCallbackQueue = CallbackQueue.getPooled();\n      queue.notifyAll();\n      CallbackQueue.release(queue);\n    }\n  }\n};\n\n/**\n * Mark a component as needing a rerender, adding an optional callback to a\n * list of functions which will be executed once the rerender occurs.\n */\nfunction enqueueUpdate(component) {\n  ensureInjected();\n\n  // Various parts of our code (such as ReactCompositeComponent's\n  // _renderValidatedComponent) assume that calls to render aren't nested;\n  // verify that that's the case. (This is called by each top-level update\n  // function, like setState, forceUpdate, etc.; creation and\n  // destruction of top-level components is guarded in ReactMount.)\n\n  if (!batchingStrategy.isBatchingUpdates) {\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\n    return;\n  }\n\n  dirtyComponents.push(component);\n  if (component._updateBatchNumber == null) {\n    component._updateBatchNumber = updateBatchNumber + 1;\n  }\n}\n\n/**\n * Enqueue a callback to be run at the end of the current batching cycle. Throws\n * if no updates are currently being performed.\n */\nfunction asap(callback, context) {\n  invariant(batchingStrategy.isBatchingUpdates, \"ReactUpdates.asap: Can't enqueue an asap callback in a context where\" + 'updates are not being batched.');\n  asapCallbackQueue.enqueue(callback, context);\n  asapEnqueued = true;\n}\n\nvar ReactUpdatesInjection = {\n  injectReconcileTransaction: function (ReconcileTransaction) {\n    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;\n    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;\n  },\n\n  injectBatchingStrategy: function (_batchingStrategy) {\n    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;\n    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;\n    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;\n    batchingStrategy = _batchingStrategy;\n  }\n};\n\nvar ReactUpdates = {\n  /**\n   * React references `ReactReconcileTransaction` using this property in order\n   * to allow dependency injection.\n   *\n   * @internal\n   */\n  ReactReconcileTransaction: null,\n\n  batchedUpdates: batchedUpdates,\n  enqueueUpdate: enqueueUpdate,\n  flushBatchedUpdates: flushBatchedUpdates,\n  injection: ReactUpdatesInjection,\n  asap: asap\n};\n\nmodule.exports = ReactUpdates;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}