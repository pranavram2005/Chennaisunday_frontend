{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nvar EventPluginHub = require('./EventPluginHub');\nvar EventPluginUtils = require('./EventPluginUtils');\nvar accumulateInto = require('./accumulateInto');\nvar forEachAccumulated = require('./forEachAccumulated');\nvar warning = require('fbjs/lib/warning');\nvar getListener = EventPluginHub.getListener;\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(inst, event, propagationPhase) {\n  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(inst, registrationName);\n}\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(inst, phase, event) {\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;\n  }\n  var listener = listenerAtPhase(inst, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    var targetInst = event._targetInst;\n    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;\n    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(inst, ignoredDirection, event) {\n  if (event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(inst, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event._targetInst, null, event);\n  }\n}\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\nfunction accumulateEnterLeaveDispatches(leave, enter, from, to) {\n  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);\n}\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing event a\n * single one.\n *\n * @constructor EventPropagators\n */\nvar EventPropagators = {\n  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,\n  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,\n  accumulateDirectDispatches: accumulateDirectDispatches,\n  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches\n};\nmodule.exports = EventPropagators;","map":{"version":3,"names":["EventPluginHub","require","EventPluginUtils","accumulateInto","forEachAccumulated","warning","getListener","listenerAtPhase","inst","event","propagationPhase","registrationName","dispatchConfig","phasedRegistrationNames","accumulateDirectionalDispatches","phase","process","env","NODE_ENV","listener","_dispatchListeners","_dispatchInstances","accumulateTwoPhaseDispatchesSingle","traverseTwoPhase","_targetInst","accumulateTwoPhaseDispatchesSingleSkipTarget","targetInst","parentInst","getParentInstance","accumulateDispatches","ignoredDirection","accumulateDirectDispatchesSingle","accumulateTwoPhaseDispatches","events","accumulateTwoPhaseDispatchesSkipTarget","accumulateEnterLeaveDispatches","leave","enter","from","to","traverseEnterLeave","accumulateDirectDispatches","EventPropagators","module","exports"],"sources":["D:/Project_CS/react_side/myapp/node_modules/react-file-viewer/node_modules/react-dom/lib/EventPropagators.js"],"sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nvar EventPluginHub = require('./EventPluginHub');\nvar EventPluginUtils = require('./EventPluginUtils');\n\nvar accumulateInto = require('./accumulateInto');\nvar forEachAccumulated = require('./forEachAccumulated');\nvar warning = require('fbjs/lib/warning');\n\nvar getListener = EventPluginHub.getListener;\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(inst, event, propagationPhase) {\n  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(inst, registrationName);\n}\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(inst, phase, event) {\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;\n  }\n  var listener = listenerAtPhase(inst, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    var targetInst = event._targetInst;\n    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;\n    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(inst, ignoredDirection, event) {\n  if (event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(inst, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event._targetInst, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\n\nfunction accumulateEnterLeaveDispatches(leave, enter, from, to) {\n  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);\n}\n\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing event a\n * single one.\n *\n * @constructor EventPropagators\n */\nvar EventPropagators = {\n  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,\n  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,\n  accumulateDirectDispatches: accumulateDirectDispatches,\n  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches\n};\n\nmodule.exports = EventPropagators;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}